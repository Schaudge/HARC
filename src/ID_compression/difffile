Only in ../../../variantcalling/IDs/ID_compressor_geneComp: 9799_short.sam.IDs
Only in .: bin
Only in .: compress
Only in .: debug
Only in .: decompress
Only in .: difffile
Only in .: .DS_Store
Only in .: .git
diff -ar ./include/Arithmetic_stream.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/Arithmetic_stream.h
45c45
< extern int file_available;
---
> int file_available;
diff -ar ./include/aux_data.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/aux_data.h
15,16d14
< #define TAGTYPELUTLENGTH 44
< //#define TAGTYPELUTLENGTH 43
17a16
> #define TAGTYPELUTLENGTH 44
24c23
< #define MAX_AUX_LENGTH UINT16_MAX //max. length of an aux field
---
> #define MAX_AUX_LENGTH 256 //max. length of an aux field
29c28
< #define MAX_CIGAR_LENGTH 2048 //Twice as long as MAX_READ_LENGTH
---
> #define MAX_CIGAR_LENGTH 100
41c40
< //static char tagTypeLUT[TAGTYPELUTLENGTH][4] = {"AMi","ASi","BCZ","BQZ","CCZ","CMi","COZ","CPi","CQZ","CSZ","CTZ","E2Z","FIi","FSZ","FZB","LBZ","H0i","H1i","H2i","HIi","IHi","MCZ","MDZ","MQi","NHi","NMi","OQZ","OPi","OCZ","PGZ","PQi","PTZ","PUZ","QTZ","Q2Z","R2Z","RGZ","RTZ","SAZ","SMi","TCi","U2Z","UQi"};
---
> //static char tagTypeLUT[MAXLUT][4] =
Only in ./include: CMakeLists.txt
Only in ./include: .DS_Store
Only in ./include: edit.h
Only in ./include: id_compression.h
Only in ./include: libssh
diff -ar ./include/pmf.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/pmf.h
4c4,5
< #include <cstdint>
---
> #include <stdint.h>
> 
8c9
< #define ALPHABET_SYMBOL_NOT_FOUND		  ((uint32_t) -1)	
---
> #define ALPHABET_SYMBOL_NOT_FOUND			UINT32_MAX
78c79
< void alphabet_union(const struct alphabet_t *__restrict__ a, const struct alphabet_t *__restrict__ b, struct alphabet_t *result);
---
> void alphabet_union(const struct alphabet_t *restrict a, const struct alphabet_t *restrict b, struct alphabet_t *result);
diff -ar ./include/quantizer.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/quantizer.h
17,19c17,19
< 	const struct alphabet_t *__restrict__ alphabet;
< 	struct alphabet_t *__restrict__ output_alphabet;
< 	symbol_t *__restrict__ q;
---
> 	const struct alphabet_t *restrict alphabet;
> 	struct alphabet_t *restrict output_alphabet;
> 	symbol_t *restrict q;
29c29
< struct quantizer_t *generate_quantizer(struct pmf_t *__restrict__ pmf, struct distortion_t *__restrict__ dist, uint32_t states);
---
> struct quantizer_t *generate_quantizer(struct pmf_t *restrict pmf, struct distortion_t *restrict dist, uint32_t states);
32c32
< struct pmf_t *apply_quantizer(struct quantizer_t *__restrict__ q, struct pmf_t *__restrict__ pmf, struct pmf_t *__restrict__ output);
---
> struct pmf_t *apply_quantizer(struct quantizer_t *restrict q, struct pmf_t *restrict pmf, struct pmf_t *restrict output);
diff -ar ./include/qv_codebook.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/qv_codebook.h
86,87c86,87
< void store_cond_quantizers(struct quantizer_t *__restrict__ lo, struct quantizer_t *__restrict__ hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, symbol_t prev);
< void store_cond_quantizers_indexed(struct quantizer_t *__restrict__ lo, struct quantizer_t *__restrict__ hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, uint32_t index);
---
> void store_cond_quantizers(struct quantizer_t *restrict lo, struct quantizer_t *restrict hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, symbol_t prev);
> void store_cond_quantizers_indexed(struct quantizer_t *restrict lo, struct quantizer_t *restrict hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, uint32_t index);
diff -ar ./include/read_compression.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/read_compression.h
14,18d13
< #include <inttypes.h>
< #include "edit.h"
< #include "id_compression.h"
< #include <cstdint>
< #include <limits>
20a16,17
> #define UINT16_MAX ((uint16_t) - 1)
> 
31c28,33
< extern char *reference;
---
> char *reference;
> 
> uint8_t snpInRef[MAX_BP_CHR];
> uint32_t cumsumP;
> 
> 
33,34d34
< extern uint8_t snpInRef[MAX_BP_CHR];
< extern uint32_t cumsumP;
56c56
< uint32_t compress_edits(Arithmetic_stream as, read_models rs, char *edits, char *cigar, char *read, uint32_t P, uint32_t deltaP, uint8_t flag, uint8_t* cigarFlags);
---
> uint32_t compress_edits(Arithmetic_stream as, read_models rs, char *edits, char *cigar, char *read, uint32_t P, uint8_t flag, uint8_t* cigarFlags);
60,61d59
< void absolute_to_relative(uint32_t *Dels, uint32_t numDels, ins *Insers, uint32_t numIns);
< 
75c73
< uint32_t reconstruct_read(Arithmetic_stream as, read_models models, uint32_t pos, uint8_t invFlag, char *read, uint32_t readLen, uint8_t chr_change, char *recCigar);
---
> uint32_t reconstruct_read(Arithmetic_stream as, read_models models, uint32_t pos, uint8_t invFlag, char *read, uint32_t readLen, char *recCigar);
77a76
> 
diff -ar ./include/sam_block.h ../../../variantcalling/IDs/ID_compressor_geneComp/include/sam_block.h
63c63
<     char cigar[MAX_CIGAR_LENGTH];
---
>     char cigar[1024];
79d78
<     FILE *funmapped;
368c367
< enum BASEPAIR char2basepair(char c);
---
> int char2basepair(char c);
371d369
< enum token_type uint8t2token(uint8_t tok);
460a459
> 
diff -ar ./src/Arithmetic_stream.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/Arithmetic_stream.c
12d11
< int file_available = 0;
Only in ./src: Arithmetic_stream.o
diff -ar ./src/aux_compression.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/aux_compression.c
73,74d72
< 
< 
115,116d112
< 
< 
157c153
<     static char list[MOST_COMMON_SEARCHLIST_SIZE+1][MAX_AUX_LENGTH] = {0};
---
>     char list[MOST_COMMON_SEARCHLIST_SIZE+1][MAX_AUX_LENGTH] = {0};
159c155
< 
---
>     
161c157
< 
---
>     
164c160
< 
---
>     
167c163
< 
---
>     
174c170
< 
---
>     
177c173
< 
---
>     
180c176
< 
---
>         
183c179
< 
---
>         
185c181
< 
---
>             
189c185
< 
---
>             
204c200
< 
---
>                 
210c206
< 
---
>                     
214c210
< 
---
>                 
217c213,216
< 
---
>             
>         }
>         if (analyzedLines == 45503){
>             
220c219
< 
---
>         
222a222
>     
224,225c224
< 
< 
---
>     
244,245c243,244
< 
< 
---
>     
>     
251,252c250,251
< 
< 
---
>     
>     
256c255
< 
---
>     
268c267
< 
---
>     
278c277
< 
---
>     
282c281
< 
---
>     
285a285,287
> 
> 
> 
291c293
< 
---
>     
355c357
< 
---
>     
359,360d360
< 
<     uint32_t index = 0;
364c364
< 
---
>         
367,369c367
<             //assert(strlen(recCigar) == index);
<             sprintf(recCigar + index,"%dS",cid[i].num);
<             index += compute_num_digits(cid[i].num) + 1;
---
>             sprintf(recCigar + strlen(recCigar),"%dS",cid[i].num);
373,378c371,372
<             assert(strlen(recCigar) == index);
<             sprintf(recCigar + index,"%dM",valM);
<             index += compute_num_digits(valM) + 1;
<             //assert(strlen(recCigar) == index);
<             sprintf(recCigar + index,"%d%c",cid[i].num,cid[i].letter);
<             index += compute_num_digits(cid[i].num) + 1;
---
>             sprintf(recCigar + strlen(recCigar),"%dM",valM);
>             sprintf(recCigar + strlen(recCigar),"%d%c",cid[i].num,cid[i].letter);
380c374
< 
---
>         
382,383c376,377
<         totalCnt += valN + valM;
<     }
---
>             totalCnt += valN + valM;
>             }
385d378
<     /*
394c387
<     //if(strcmp(recCigar,origCigar)!=0) printf("No match =( \n%s\n%s\n\n",origCigar,recCigar);*/
---
>     //if(strcmp(recCigar,origCigar)!=0) printf("No match =( \n%s\n%s\n\n",origCigar,recCigar);
397d389
< 
Only in ./src: aux_compression.o
diff -ar ./src/compression.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/compression.c
12d11
< #include <stdbool.h>
16c15,16
< int print_line(struct sam_line_t *sline, uint8_t print_mode, FILE *fs, bool compressing){
---
> 
> int print_line(struct sam_line_t *sline, uint8_t print_mode, FILE *fs){
20a21
>     fprintf(fs, "%s",sline->ID);
21a23
>     /* ######
24,37c26,45
<             fprintf(fs, "%s\t", sline->ID);
<             fprintf(fs, "%d\t", sline->flag);
<             fprintf(fs, "%s\t", sline->rname);
<             fprintf(fs, "%d\t", sline->pos);
<             fprintf(fs, "%d\t", sline->mapq);
<             fprintf(fs, "%s\t", sline->cigar);
<             fprintf(fs, "%s\t", sline->rnext); 
<             fprintf(fs, "%d\t", sline->pnext);
<             fprintf(fs, "%d\t", sline->tlen);
<             fprintf(fs, "%s\t", sline->read);
<             // need to re-reverse quality scores
<             if ((sline->flag & 16) == 16 && !compressing) {
< 		//printf("sline print line is: %d\n", sline->readLength);
<                 for (i = sline->readLength - 1; i >= 0; --i)
---
>             if ((sline->flag & 16) == 16) {
>                 // We need to inverse the read and QV
>                 fprintf(fs, "%s\t%d\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t",
>                         sline->ID,
>                         sline->flag,
>                         sline->rname,
>                         sline->pos,
>                         sline->mapq,
>                         sline->cigar,
>                         //foo,
>                         sline->rnext,
>                         sline->pnext,
>                         sline->tlen
>                         );
>                 for (i = sline->readLength - 1; i >=0 ; --i)
>                     fputc(bp_complement(sline->read[i]), fs);
>                     
>                 fputc('\t', fs);
>                 
>                 for (i = sline->readLength - 1; i >=0 ; --i)
38a47
>                 
40,41c49,71
<             } else {
<                 fprintf(fs, "%s\t", sline->quals);
---
>                 
>                 fprintf(fs, "%s",sline->aux);
>                 
>                 fputc('\n', fs);
>             }
>             else{
>                 
>                 //before: "%s \t %d \t %s \t %d \t %d \t %s \t %s \t %d \t %d \t %s \t %s\n",
>                 fprintf(fs, "%s\t%d\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n",
>                    sline->ID,
>                    sline->flag,
>                    sline->rname,
>                    sline->pos,
>                    sline->mapq,
>                    sline->cigar,
>                    //foo,
>                    sline->rnext,
>                    sline->pnext,
>                    sline->tlen,
>                    sline->read,
>                    sline->quals,
>                    sline->aux
>                    );
43,44d72
<             fprintf(fs, "%s", sline->aux);  
<             fputc('\n', fs); 
49a78
>      */
53,57c82
< int print_line(struct sam_line_t *sline, uint8_t print_mode, FILE *fs) {
<     return print_line(sline, print_mode, fs, false);
< }
< 
< int compress_line(Arithmetic_stream as, sam_block samBlock, FILE *funmapped, uint8_t lossiness)  {
---
> int compress_line(Arithmetic_stream as, sam_block samBlock, uint8_t lossiness)  {
59d83
<     static bool unmapped_reads = false;
61c85
<     
---
>     //printf("before load sam line: %d\n", samBlock->read_length);
62a87
>     
65,100c90,93
<     //printf("sam line loaded\n");
<  
<     // If read is unmapped and reference name is *, we assume that all the remaining
<     // lines are unmapped and have reference name *.
<     // If the read is unmapped but has a position/reference name, we simply use that
<     // information to compress it.
<     if ( (samBlock->reads->lines->invFlag & 4) == 4 && *samBlock->rnames->rnames[0] == '*'){
<         read_line line = samBlock->reads->lines; 
< 
<         fprintf(funmapped, "%s\t", *samBlock->IDs->IDs);
<         fprintf(funmapped, "%d\t", line->invFlag);
<         fprintf(funmapped, "%s\t", *samBlock->rnames->rnames);
<         fprintf(funmapped, "%d\t", line->pos);
<         fprintf(funmapped, "%d\t", *samBlock->mapq->mapq);
<         fprintf(funmapped, "%s\t", line->cigar);
<         fprintf(funmapped, "%s\t", *samBlock->rnext->rnext); 
<         fprintf(funmapped, "%d\t", *samBlock->pnext->pnext);
<         fprintf(funmapped, "%d\t", *samBlock->tlen->tlen);
<         fprintf(funmapped, "%s\t", line->read);
<         int32_t i = 0;
<         qv_line_t qline = *samBlock->QVs->qv_lines;
<         if ((line->invFlag & 16) == 16) {
<             for (i = qline.columns - 1; i >= 0; i--) {
<                 fputc(qline.data[i] + 33, funmapped);
<             }
<         } else {
<             for (i = 0; i < qline.columns; i++) {
<                 fputc(qline.data[i] + 33, funmapped);
<             }
<         }
<         fputc('\t', funmapped);
<         for (i = 0; i < samBlock->aux->aux_cnt; i++) {
<             fprintf(funmapped, "%s", samBlock->aux->aux_str[i]);  
<             if (i < samBlock->aux->aux_cnt - 1) fputc('\t', funmapped);
<         }
<         fputc('\n', funmapped); 
---
>     
>     /* #######
>     //printf("after load sam line: %d\n", samBlock->reads->lines->read_length);
>     if ( (samBlock->reads->lines->invFlag & 4) == 4) {
102,106d94
<     } else {
<         if (unmapped_reads) {
<             fprintf(stderr, "compress_line error: There is a mapped read following a read that is not mapped to any chromosome. This probably means that the sam file is not correctly sorted.\n");
<             exit(1);
<         }
108c96
<         
---
>      */
112c100,101
<         
---
>     
>     /* ########
114d102
< 
117c105
<         // Reset cumsumP
---
>         // Clean snpInRef vector and reset cumsumP
120a109
>      */
123c112,113
< 
---
>     
>     /* ########
125c115
< 
---
>     
127c117
< 
---
>     
129a120,121
>     //At the end of compress_edits (in compress_read) happens the computation of whether we can recover the cigar just from the indels data or not, so the cigar compression must be done after compress_read.
>     
131c123,124
< 
---
>     
>     
133,134d125
< 
<     compress_pnext_raw(as, samBlock->pnext->models,  samBlock->reads->lines->pos, *samBlock->pnext->pnext);
135a127
>     compress_pnext_raw(as, samBlock->pnext->models,  samBlock->reads->lines->pos, *samBlock->pnext->pnext);
142c134,135
< 
---
>     //compress_pnext(as, samBlock->pnext->models, samBlock->reads->lines->pos, *samBlock->tlen->tlen, *samBlock->pnext->pnext, (*samBlock->rnext->rnext[0] != '='), samBlock->reads->lines->cigar);
>     
146a140,141
>     
>     */
160,162c155,157
<     sline.readLength = samBlock->read_length;
<     //sline.readLength = samBlock->reads->models->read_length;
<     //printf("sline read length is: %d\n", sline.readLength); 
---
>     //sline.readLength = samBlock->read_length;
>     // ######## sline.readLength = samBlock->reads->models->read_length;
>     
170c165,166
<         
---
>     
>     /* ######
178c174
<         // reset cumsumP
---
>         // Clean snpInRef vector and reset cumsumP
180d175
< 
182d176
< 
184c178,179
< 
---
>      */
>         
186c181,182
< 
---
>     
>     /* #######
188,190c184,186
< 
<     decompress_rnext(as, samBlock->rnext->models, sline.rnext); 
< 
---
>     
>     decompress_rnext(as, samBlock->rnext->models, sline.rnext);
>         
194c190
< 
---
>     
196c192
< 
---
>     
198c194
< 
---
>     
203d198
<     
208,212c203,205
<         QVs_decompress_lossless(as, samBlock->QVs, decompression_flag, sline.quals, (int)strlen(sline.read));
< 
<    
<     sline.readLength = samBlock->reads->models->read_length;
<     // printf("sline read length before printing is: %d\n", sline.readLength); 
---
>         QVs_decompress_lossless(as, samBlock->QVs, decompression_flag, sline.quals, strlen(sline.read));
>     
>      */
214c207
< 
---
>     
217a211
> 
225c219
< 
---
>     
232c226
< 
---
>     
243c237
< 
---
>     
245c239
< 
---
>     
252c246
< 
---
>         
254c248,332
<         //printf("%d -> %s\n",i,aux->most_common[i]);
---
>         printf("%d -> %s\n",i,aux->most_common[i]);
>     }
>     // Added by Idoia: 10/03/2016
>     return 1;
> }
> 
> 
> /*int compress_block(Arithmetic_stream as, sam_block samBlock){
>     
>     unsigned int i = 0;
>     uint8_t chr_change;
>     
>     float counts_rname = 0, counts_id = 0, counts_reads = 0, counts_qv = 0, counts_load = 0, counts_qv_model = 0, counts_quant = 0;
>     
>     clock_t begin;
>     
>     symbol_t *qArray;
>     
>     // Load the data from the first block
>     //printf("Loading block of data into memory...\n");
>     begin = clock();
>     load_sam_block(samBlock);
>     counts_load = (float)(clock() - begin)/CLOCKS_PER_SEC;
>     // Compute the codebook and initialize the QV model
>     //printf("Computing the codebook for the QVs...\n");
>     begin = clock();
>     initialize_qv_model(as, samBlock->QVs, COMPRESSION);
>     //initialize_stream_model_qv_full(samBlock->QVs->model, samBlock->QVs->qlist);
>     counts_qv_model = (float)(clock() - begin)/CLOCKS_PER_SEC;
>     
>     begin = clock();
>     //quantize_block(samBlock->QVs, samBlock->read_length);
>     qArray = copy_qlis_to_array(samBlock->QVs);
>     printf("lala %f\n",  (float)(clock() - begin)/CLOCKS_PER_SEC);
>     
>     //printf("Compressing the block...\n");
>     // Loop over the lines of the sam block
>     for (i = 0; i < samBlock->block_length; i++) {
>         
>         // Compress sam line
>         begin = clock();
>         chr_change = compress_rname(as, samBlock->rnames->models, samBlock->rnames->rnames[i]);
>         counts_rname += (float)(clock() - begin)/CLOCKS_PER_SEC;
>         
>         if (chr_change == 1){
>             
>             // Store Ref sequence in memory
>             store_reference_in_memory(samBlock->fref);
>             
>             // Clean snpInRef vector and reset cumsumP
>             cumsumP = 0;
>             memset(snpInRef, 0, MAX_BP_CHR);
>         }
>         begin = clock();
>         compress_id(as, samBlock->IDs->models, samBlock->IDs->IDs[i]);
>         counts_id += (float)(clock() - begin)/CLOCKS_PER_SEC;
>         begin = clock();
>         compress_read(as, samBlock->reads->models, &(samBlock->reads->lines[i]), chr_change);
>         counts_reads += (float)(clock() - begin)/CLOCKS_PER_SEC;
>         //begin = clock();
>         //quantize_line(samBlock->QVs, &(samBlock->QVs->qv_lines[i]), samBlock->read_length);
>         //counts_quant += (float)(clock() - begin)/CLOCKS_PER_SEC;
>         begin = clock();
>         //QVs_compress(as, samBlock->QVs, &(samBlock->QVs->qv_lines[i]), qArray);
> //        QVs_compress(as, samBlock->QVs, i, qArray);
>         //QVs_compress2(as, samBlock->QVs->qlist->input_alphabets, samBlock->QVs->qlist->qratio, &(samBlock->QVs->qv_lines[i]), qArray, samBlock->QVs->model, &(samBlock->QVs->well));
>         //QVs_compress3(as, samBlock->QVs->model, &(samBlock->QVs->qv_lines[i]));
>         counts_qv += (float)(clock() - begin)/CLOCKS_PER_SEC;
>     }
>     
>     printf("Time load \t %f\n", ((float)counts_load));
>     printf("Time qv_model \t %f\n", ((float)counts_qv_model));
>     printf("Time rname \t %f\n", ((float)counts_rname));
>     printf("Time id \t %f\n", ((float)counts_id));
>     printf("Time reads \t %f\n", ((float)counts_reads));
>     
>     printf("Time quant \t %f\n", ((float)counts_quant));
>     printf("Time qv \t %f\n", ((float)counts_qv));
>     
>     
>     
>     // Check if we are in the last block
>     if (i < MAX_LINES_PER_BLOCK){
>         compress_rname(as, samBlock->rnames->models, "\n");
>         return 0;
255a334
>     
258a338,381
> int decompress_block(Arithmetic_stream as, sam_block samBlock){
>     
>     unsigned int i = 0;
>     
>     int32_t chr_change = 0;
>     
>     //uint32_t decompression_flag = 0;
>     
>     // initialize the QV model
>     printf("Computing the codebook for the QVs...\n");
>     initialize_qv_model(as, samBlock->QVs, DECOMPRESSION);
>     
>     printf("Decompressing the block...\n");
>     // Loop over the lines of the sam block
>     for (i = 0; i < samBlock->block_length; i++) {
>         
>         chr_change = decompress_rname(as, samBlock->rnames->models, NULL);
>         
>         if (chr_change == -1)
>             return 0;
>         
>         if (chr_change == 1){
>             
>             //printf("Chromosome %d decompressed.\n", ++chrCtr);
>             
>             // Store Ref sequence in memory
>             store_reference_in_memory(samBlock->fref);
>             
>             // Clean snpInRef vector and reset cumsumP
>             cumsumP = 0;
>             memset(snpInRef, 0, MAX_BP_CHR);
>         }
>         
>         //decompress_id(as, samBlock->IDs->models, samBlock->fs);
>         
>         //decompression_flag = decompress_read(as,samBlock, chr_change);
>         
>         //QVs_decompress(as, samBlock->QVs, samBlock->fs, decompression_flag);
>         
>     }
>     
>     return 1;
> }*/
> 
267c390
<     unsigned long long lineCtr = 0;
---
>     uint32_t lineCtr = 0;
281a405
>     /* ########
282a407
>     // Create the list of the most common aux fields
284c409,411
<     compress_most_common_list(as, samBlock->aux);
---
>     
>     // 'Compress' (very naive approach) the most_common_list.
>     compress_most_common_list(as,samBlock->aux);
286a414
>     
293,298c421,425
<    
<    printf("start line compression\n"); 
<     while (compress_line(as, samBlock, info.funmapped, info.lossiness)) {
<         ++lineCtr;
<         if (lineCtr % 1000000 == 0) {
<           printf("[cbc] compressed %zu lines\n", lineCtr);
---
>      */
>     while (compress_line(as, samBlock, info.lossiness)) {
>         if (lineCtr==117) {
>             printf("%d\n",lineCtr);
>             
299a427
>         ++lineCtr;
300a429,434
>     // Load and compress the blocks
>     //while(compress_block(as, samBlock)){
>     //    reset_QV_block(samBlock->QVs, info.mode);
>     
>     //   n += samBlock->block_length;
>     //}
308a443,447
>     //printf("%f Million reads compressed using %f MB.\n", (double)n/1000000.0, (double)compress_file_size/1000000.0);
>     
>     // free(samLine->cigar), free(samLine.edits), free(samLine.read_), free(samLine.identifier), free(samLine.refname);
>     
>     fclose(info.fsam);
312c451
<     printf("Compression (mapped reads only) took %f\n", ((float)ticks)/CLOCKS_PER_SEC);
---
>     printf("Compression took %f\n", ((float)ticks)/CLOCKS_PER_SEC);
325d463
< 
332c470
<     decompress_most_common_list(as, samBlock->aux);
---
>     // ######## decompress_most_common_list(as, samBlock->aux);
334c472
<     info->lossiness = decompress_int(as, samBlock->codebook_model);
---
>     // ########## info->lossiness = decompress_int(as, samBlock->codebook_model);
335a474
>     /* ######
340a480
>     */
343a484,487
>         //reset_QV_block(samBlock->QVs, DECOMPRESSION);
>         if (n==898){
>             
>         }
348a493,495
>     //end the decompression
>     //compress_file_size = encoder_last_step(as);
>     
350c497,506
<     printf("Decompression (mapped reads only) took %f\n", ((float)ticks)/CLOCKS_PER_SEC);
---
>     
>     printf("Decompression took %f\n", ((float)ticks)/CLOCKS_PER_SEC);
>     
>     //printf("%f Million reads decompressed.\n", (double)n/1000000.0);
>     
>     // free(samLine->cigar), free(samLine.edits), free(samLine.read_), free(samLine.identifier), free(samLine.refname);
>     
>     fclose(info->fsam);
>     // ####### fclose(info->fref);
>     
Only in ./src: compression.o
Only in ./src: distortion.o
Only in ./src: .DS_Store
Only in ./src: edit.cc
Only in ./src: edit.o
diff -ar ./src/id_compression.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/id_compression.c
161a162,163
>     else
>     
475a478
> 
508a512
> 
522c526
<     while ( (tok = uint8t2token(decompress_uint8t(as, model->token_type[token_ctr]))) != ID_END ) {
---
>     while ( (tok = decompress_uint8t(as, model->token_type[token_ctr])) != ID_END ) {
583a588,591
> 
> 
> 
> 
594c602
<     int32_t i,j,k; char *auxPtr;
---
>     int i,j,k; char *auxPtr;
661c669,671
< 
---
>             
>             
>             // new from geneComp
669a680,691
>             
>             
>             /*
>             // This is gone
>             if(k<0) {
>                 compress_uint8t(as, models->sign_integers[0], 1);
>                 k=-k;
>             } else {
>                 compress_uint8t(as, models->sign_integers[0], 0);
>             }
>             compress_uint8t(as, models->integers[0], k); //ALERTA! k > 255?
>              */
670a693,695
>             
>             
>             // NEw GeneComp
673c698
<               desc_length=UINT16_MAX;
---
>                 desc_length=UINT16_MAX;
678c703
< 
---
>             
687a713,727
>          
>             
>             /*
>             desc_length = strlen(ptr_data);
>             if(desc_length>256) desc_length=256;
>             
>             compress_uint8t(as, models->descBytes[0], (uint8_t)desc_length);
>             
>             uint8_t buffer[256] = {0};
>             uint8_t buff_cnt = 0;
>             while (*ptr_data!=0) {
>                 compress_uint8t(as, models->iidBytes[0], *ptr_data);
>                 ptr_data++;
>             }
>             */
694a735,736
> 
> 
703c745
<     uint16_t desc_length = 0;
---
>     uint8_t desc_length;
751c793,795
<         char buffer[MAX_AUX_LENGTH] = {0};
---
>         //uint8_t buffer[256] = {0};
>         uint8_t buffer[MAX_AUX_LENGTH] = {0};
>         
754a799,800
>             
>             //NEW
761a808,816
>             
>             /*
>             sign = decompress_uint8t(as, models->sign_integers[0]);
>             value = decompress_uint8t(as, models->integers[0]); //alerta (ver analogo en comp)
>             if(sign==1) value = -value;
>             sprintf(buffer,"%d",value);
>             desc_length = strlen(buffer);
>             buffer[desc_length] = '\t';
>              */
769a825,834
>             
>             /*
>             //value dec.
>             desc_length = decompress_uint8t(as, models->descBytes[0]);
> 
>             for (buff_cnt=0;buff_cnt<desc_length;buff_cnt++) {
>                 buffer[buff_cnt] = decompress_uint8t(as, models->iidBytes[0]);
>             }
>             buffer[buff_cnt] = '\t';
>          */
795,797d859
< 
< 
< 
812c874
<     
---
> 
835c897
<             
---
>         
842c904
<                 
---
>             
847c909
<                 
---
>             
850c912
<                 
---
>             
873c935
<         
---
>     
957,967c1019,1029
<              if(k<0) {
<              //compress_uint8t(as, models->sign_integers[0], 1);
<              compress_uint8t(as, models->sign_integers_wContext[prev_numericTagType], 1);
<              k=-k;
<              } else {
<              //compress_uint8t(as, models->sign_integers[0], 0);
<              compress_uint8t(as, models->sign_integers_wContext[prev_numericTagType], 0);
<              }
<              //compress_uint8t(as, models->integers[0], k); //ALERTA! k > 255?
<              compress_uint8t(as, models->integers_wContext[prev_numericTagType], k); //ALERTA! k > 255?
<              */
---
>             if(k<0) {
>                 //compress_uint8t(as, models->sign_integers[0], 1);
>                 compress_uint8t(as, models->sign_integers_wContext[prev_numericTagType], 1);
>                 k=-k;
>             } else {
>                 //compress_uint8t(as, models->sign_integers[0], 0);
>                 compress_uint8t(as, models->sign_integers_wContext[prev_numericTagType], 0);
>             }
>             //compress_uint8t(as, models->integers[0], k); //ALERTA! k > 255?
>             compress_uint8t(as, models->integers_wContext[prev_numericTagType], k); //ALERTA! k > 255?
>             */
991,1003c1053,1065
<              desc_length = strlen(ptr_data);
<              if(desc_length>256) desc_length=256;
<              
<              //compress_uint8t(as, models->descBytes[0], (uint8_t)desc_length);
<              compress_uint8t(as, models->descBytes_wContext[prev_numericTagType], (uint8_t)desc_length);
<              
<              uint8_t buffer[256] = {0};
<              uint8_t buff_cnt = 0;
<              while (*ptr_data!=0) {
<              //compress_uint8t(as, models->iidBytes[0], *ptr_data);
<              compress_uint8t(as, models->iidBytes_wContext[prev_numericTagType], *ptr_data);
<              ptr_data++;
<              }
---
>             desc_length = strlen(ptr_data);
>             if(desc_length>256) desc_length=256;
>             
>             //compress_uint8t(as, models->descBytes[0], (uint8_t)desc_length);
>             compress_uint8t(as, models->descBytes_wContext[prev_numericTagType], (uint8_t)desc_length);
>             
>             uint8_t buffer[256] = {0};
>             uint8_t buff_cnt = 0;
>             while (*ptr_data!=0) {
>                 //compress_uint8t(as, models->iidBytes[0], *ptr_data);
>                 compress_uint8t(as, models->iidBytes_wContext[prev_numericTagType], *ptr_data);
>                 ptr_data++;
>             }
1073c1135
<             
---
>         
1079c1141
<                 
---
>             
1082c1144
<                 
---
>             
1086,1087c1148,1149
<                 
<                 
---
>             
>             
1105c1167
<                 
---
>         
1153c1215
<             char buffer[MAX_AUX_LENGTH] = {0};
---
>             uint8_t buffer[MAX_AUX_LENGTH] = {0};
1171,1181c1233,1243
<                  //sign = decompress_uint8t(as, models->sign_integers[0]);
<                  //value = decompress_uint8t(as, models->integers[0]); //alerta (ver analogo en comp)
<                  
<                  sign = decompress_uint8t(as, models->sign_integers_wContext[prev_tagtypeLUTindex]);
<                  value = decompress_uint8t(as, models->integers_wContext[prev_tagtypeLUTindex]); //alerta (ver analogo en comp)
<                  
<                  if(sign==1) value = -value;
<                  sprintf(buffer,"%d",value);
<                  desc_length = strlen(buffer);
<                  buffer[desc_length] = '\t';
<                  */
---
>                 //sign = decompress_uint8t(as, models->sign_integers[0]);
>                 //value = decompress_uint8t(as, models->integers[0]); //alerta (ver analogo en comp)
>                 
>                 sign = decompress_uint8t(as, models->sign_integers_wContext[prev_tagtypeLUTindex]);
>                 value = decompress_uint8t(as, models->integers_wContext[prev_tagtypeLUTindex]); //alerta (ver analogo en comp)
>                 
>                 if(sign==1) value = -value;
>                 sprintf(buffer,"%d",value);
>                 desc_length = strlen(buffer);
>                 buffer[desc_length] = '\t';
>                 */
1193,1201c1255,1263
<                  //value dec.
<                  //desc_length = decompress_uint8t(as, models->descBytes[0]);
<                  desc_length = decompress_uint8t(as, models->descBytes_wContext[prev_tagtypeLUTindex]);
<                  
<                  for (buff_cnt=0;buff_cnt<desc_length;buff_cnt++) {
<                  //buffer[buff_cnt] = decompress_uint8t(as, models->iidBytes[0]);
<                  buffer[buff_cnt] = decompress_uint8t(as, models->iidBytes_wContext[prev_tagtypeLUTindex]);
<                  }
<                  buffer[buff_cnt] = '\t';
---
>                 //value dec.
>                 //desc_length = decompress_uint8t(as, models->descBytes[0]);
>                 desc_length = decompress_uint8t(as, models->descBytes_wContext[prev_tagtypeLUTindex]);
>                 
>                 for (buff_cnt=0;buff_cnt<desc_length;buff_cnt++) {
>                     //buffer[buff_cnt] = decompress_uint8t(as, models->iidBytes[0]);
>                     buffer[buff_cnt] = decompress_uint8t(as, models->iidBytes_wContext[prev_tagtypeLUTindex]);
>                 }
>                 buffer[buff_cnt] = '\t';
1229,1233d1290
< 
< 
< 
< 
< 
Only in ./src: id_compression.o
Only in ./src: io_functions.o
diff -ar ./src/main.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/main.c
10c10,11
< #include <sys/wait.h>
---
> // ssh:idoia@171.64.93.7 password: z1627126
> 
13d13
< #include <inttypes.h>
17d16
< #include "edit.h"
21,24c20
< static char *MAPPED_READS = "mapped_reads";
< static char *HEADERS = "headers";
< static char *UNMAPPED_READS = "unmapped_reads";
< static char *ZIPPED_READS = "unmapped_reads.gz";
---
> 
49,76d44
< void change_dir(char *dir) {
<     if (chdir(dir) == -1) {
<         fprintf(stderr, "Failed to change directories to %s\n", dir);
<         exit(1);
<     }
< }
< 
< void make_dir(char *dirname) {
<     struct stat sb;
<     if (!(stat(dirname, &sb) == 0 && S_ISDIR(sb.st_mode)) && mkdir(dirname, 0777) == -1) {
<         fprintf(stderr, "Failed to create directory %s\n", dirname);
<     }
< }
< 
< void write_headers(FILE *input, FILE *output) {
<     char c;
<     while ( (c = getc(input)) != EOF) {
<         if (c != '@') {
<           break;
<         }
<         do {
<             putc(c, output);
<             c = getc(input);
<         } while (c != '\n' && c != EOF);
<         if (c == '\n') putc(c, output);
<     }
<     rewind(input);
< }
79c47
< 
---
>     
128c96,97
<                 case 2:
---
>                     /* ##############
>                  case 2:
131c100
<                     break;
---
>                     break;*/
225c194
<     
---
>     /*  ########################
230c199
<     }
---
>     }*/
270c239
<         case COMPRESSION: {
---
>         case COMPRESSION:
272,274c241,244
<             comp_info.fref = fopen ( ref_name , "r" );
< 
<             if ( comp_info.fref == NULL || comp_info.fsam == NULL ){
---
>             // ####### comp_info.fref = fopen ( ref_name , "r" );
>             comp_info.fcomp = fopen( output_name, "w");
>             // ####### if ( comp_info.fref == NULL || comp_info.fsam == NULL ){
>             if ( comp_info.fsam == NULL ){
277,287d246
< 
<             make_dir(output_name);
<             change_dir(output_name);
< 
<             FILE *headers_file = fopen(HEADERS, "w");
<             write_headers(comp_info.fsam, headers_file);
<             fclose(headers_file);
< 
< 
<             comp_info.funmapped = fopen(UNMAPPED_READS, "w");
<             comp_info.fcomp = fopen(MAPPED_READS, "w");
291,305d249
<             fclose(comp_info.funmapped);
< 
<             pid_t pid = fork();
<             if (pid == 0) {
<                 char* argv[4];
<                 argv[0] = "gzip";
<                 argv[1] = "-fk";
<                 argv[2] = UNMAPPED_READS;
<                 argv[3] = NULL;
<                 execvp(argv[0], argv);
<                 exit(1);
<             }
<             waitpid(pid, NULL, 0);
< 
<             fclose(comp_info.fsam);
308,310c252,253
<                           }
<         case DECOMPRESSION: {
< 
---
>             
>         case DECOMPRESSION:
312,313c255,258
<             comp_info.fref = fopen ( ref_name , "r" );
<             if ( comp_info.fref == NULL || comp_info.fsam == NULL ){
---
>             // ####### comp_info.fref = fopen ( ref_name , "r" );
>             comp_info.fcomp = fopen(input_name, "r");
>             // ####### if ( comp_info.fref == NULL || comp_info.fsam == NULL ){
>             if ( comp_info.fsam == NULL ){
316,333d260
< 
<             change_dir(input_name);
<             pid_t pid = fork();
<             if (pid == 0) {
<                 char* argv[4];
<                 argv[0] = "gzip";
<                 argv[1] = "-dfk";
<                 argv[2] = ZIPPED_READS;
<                 argv[3] = NULL;
<                 execvp(argv[0], argv);
<                 exit(1);
<             }
< 
<             FILE *headers_file = fopen(HEADERS, "r");
<             write_headers(headers_file, comp_info.fsam);
<             fclose(headers_file);
< 
<             comp_info.fcomp = fopen(MAPPED_READS, "r");
337,348d263
< 
<             waitpid(pid, NULL, 0);
<             comp_info.funmapped = fopen(UNMAPPED_READS, "r");
<             char c;
<             while ( (c = getc(comp_info.funmapped)) != EOF) {
<                 putc(c, comp_info.fsam);
<             }
< 
<             fclose(comp_info.fsam);
<             fclose(comp_info.fref);
<             fclose(comp_info.funmapped);
<             fclose(comp_info.fcomp);
351c266
<                             }
---
>             
Only in ./src: main.o
diff -ar ./src/pmf.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/pmf.c
313c313
< void alphabet_union(const struct alphabet_t *__restrict__ a, const struct alphabet_t *__restrict__ b, struct alphabet_t *result) {
---
> void alphabet_union(const struct alphabet_t *restrict a, const struct alphabet_t *restrict b, struct alphabet_t *result) {
Only in ./src: pmf.o
diff -ar ./src/quantizer.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/quantizer.c
35c35
< struct quantizer_t *generate_quantizer(struct pmf_t *__restrict__ pmf, struct distortion_t *__restrict__ dist, uint32_t states) {
---
> struct quantizer_t *generate_quantizer(struct pmf_t *restrict pmf, struct distortion_t *restrict dist, uint32_t states) {
140c140
< struct pmf_t *apply_quantizer(struct quantizer_t *__restrict__ q, struct pmf_t *__restrict__ pmf, struct pmf_t *__restrict__ output) {
---
> struct pmf_t *apply_quantizer(struct quantizer_t *restrict q, struct pmf_t *restrict pmf, struct pmf_t *restrict output) {
Only in ./src: quantizer.o
diff -ar ./src/qv_codebook.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/qv_codebook.c
272c272
< void store_cond_quantizers(struct quantizer_t *__restrict__ lo, struct quantizer_t *__restrict__ hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, symbol_t prev) {
---
> void store_cond_quantizers(struct quantizer_t *restrict lo, struct quantizer_t *restrict hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, symbol_t prev) {
281c281
< void store_cond_quantizers_indexed(struct quantizer_t *__restrict__ lo, struct quantizer_t *__restrict__ hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, uint32_t idx) {
---
> void store_cond_quantizers_indexed(struct quantizer_t *restrict lo, struct quantizer_t *restrict hi, double ratio, struct cond_quantizer_list_t *list, uint32_t column, uint32_t idx) {
Only in ./src: qv_codebook.o
diff -ar ./src/qv_compression.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/qv_compression.c
214d213
<     //uint32_t columns = info->columns;
219,221c218,219
<     quals[columns] = '\0';
<     //printf("num cols is %d\n", num_cols);
<  
---
>     quals[columns] = 0;
>     
Only in ./src: qv_compression.o
Only in ../../../variantcalling/IDs/ID_compressor_geneComp/src: read_compression.c
Only in ./src: read_compression.cc
Only in ./src: read_compression.o
Only in ../../../variantcalling/IDs/ID_compressor_geneComp/src: read_decompression.c
Only in ./src: read_decompression.cc
Only in ./src: read_decompression.o
diff -ar ./src/sam_file_allocation.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/sam_file_allocation.c
72d71
< 
348c347
<     sb->fref = fref;
---
>     // ##### sb->fref = fref;
353a353,354
>     
>     /* ########3
401a403
>      */
404a407
>     
406c409
<     sb->aux = alloc_aux_block();
---
>     // ####### sb->aux = alloc_aux_block();
410c413
<     
---
>     /* #######
423c426
<     
---
>     */
480,481d482
<             qvline->columns = (int)strlen(ptr);
<             printf("Num cols is:%d\n",qvline->columns);
486c487
<                 for (j = qvline->columns - 1; j >= 0; j--) {
---
>                 for (j = sb->read_length - 1; j >= 0; j--) {
491c492
<                 for (j = 0; j < qvline->columns; j++) {
---
>                 for (j = 0; j < sb->read_length; j++) {
560a562
>     /* #######
563c565
<     
---
>     */
566a569
>      
568a572,573
>     
>     /* ######
574a580,581
>     */
>     
579a587,588
>         strcpy(rname_line, "1");
>         /* ########
607c616
< 	sb->reads->models->read_length = (uint32_t)strlen(ptr);
---
>         sb->reads->lines->read_length = (uint32_t)strlen(ptr);
612d620
<         //printf("quality score read length sam file: %d\n", strlen(ptr));
634c642
<                 strcpy(rline->edits, ptr);
---
>                 strcpy(rline->edits, ptr+5);
636,640c644,649
<             } //else {
<             strcpy(aux_fields[auxCnt], ptr);
<             auxCnt++;
<             //if we have reached the max. allowed aux fields, break.
<             if(auxCnt==MAX_AUX_FIELDS) break;
---
>             }
>             //else {
>                 strcpy(aux_fields[auxCnt], ptr);
>                 auxCnt++;
>                 //if we have reached the max. allowed aux fields, break.
>                 if(auxCnt==MAX_AUX_FIELDS) break;
648c657
<         
---
>         */
Only in ./src: sam_file_allocation.o
diff -ar ./src/sam_models.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/sam_models.c
11c11
< enum BASEPAIR char2basepair(char c)
---
> int char2basepair(char c)
15,19c15,19
<         case 'A': return A;
<         case 'C': return C;
<         case 'G': return G;
<         case 'T': return T;
<         default: return N;
---
>         case 'A': return 0;
>         case 'C': return 1;
>         case 'G': return 2;
>         case 'T': return 3;
>         default: return 4;
47,62d46
< enum token_type uint8t2token(uint8_t tok) {
<     switch(tok)
<     {
<         case 0: return ID_ALPHA;
<         case 1: return ID_DIGIT;
<         case 2: return ID_CHAR;
<         case 3: return ID_MATCH;
<         case 4: return ID_ZEROS;
<         case 5: return ID_DELTA;
<         case 6: return ID_END;
< 
<     }
<     printf("uint8t2token error: Passed in invalid number %d\n", tok);
<     assert(0);
<     return ID_END;
< }
582c566
<     read_models rtn = (read_models) calloc(1, sizeof(struct read_models_t));
---
>     read_models rtn = calloc(1, sizeof(struct read_models_t));
611c595
<     id_models rtn = (id_models) calloc(1, sizeof(struct id_models_t));
---
>     id_models rtn = calloc(1, sizeof(struct id_models_t));
631c615
<     rname_models rtn = (rname_models) calloc(1, sizeof(struct rname_models_t));
---
>     rname_models rtn = calloc(1, sizeof(struct rname_models_t));
645c629
<     mapq_models rtn = (mapq_models) calloc(1, sizeof(struct mapq_models_t));
---
>     mapq_models rtn = calloc(1, sizeof(struct mapq_models_t));
668c652
<     aux_models rtn = (aux_models) calloc(1, sizeof(struct aux_models_t));
---
>     aux_models rtn = calloc(1, sizeof(struct aux_models_t));
704d687
<     
716c699
<     rnext_models rtn = (rnext_models) calloc(1, sizeof(struct rnext_models_t));
---
>     rnext_models rtn = calloc(1, sizeof(struct rnext_models_t));
730c713
<     pnext_models rtn = (pnext_models) calloc(1, sizeof(struct pnext_models_t));
---
>     pnext_models rtn = calloc(1, sizeof(struct pnext_models_t));
748c731
<     tlen_models rtn = (tlen_models) calloc(1, sizeof(struct tlen_models_t));
---
>     tlen_models rtn = calloc(1, sizeof(struct tlen_models_t));
Only in ./src: sam_models.o
diff -ar ./src/sfio_ssh_session.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/sfio_ssh_session.c
145c145
<         buffer = (char *) malloc(length);
---
>         buffer = malloc(length);
Only in ./src: sfio_ssh_session.o
diff -ar ./src/stream_model.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/stream_model.c
10,11d9
< #include <stdbool.h>
< #define DEBUG false
77,80c75
<     if (DEBUG) {
<       printf("cumCountX: %d, cumCountX_1: %d\n", cumCountX, cumCountX_1);
<       //printf("x: %d\n", x); 
<     }
---
>     
121,124d115
<     if (DEBUG) {
<       printf("cumCountX: %d, cumCountX_1: %d\n", cumCountX, cumCountX_1);
<       //printf("x: %d\n", x); 
<     }
Only in ./src: stream_model.o
diff -ar ./src/util.c ../../../variantcalling/IDs/ID_compressor_geneComp/src/util.c
12c12
< #ifdef __linux__
---
> #ifdef LINUX
33c33
< #ifdef __linux__ 
---
> #ifdef LINUX
53c53
< #ifdef __linux__
---
> #ifdef LINUX
Only in ./src: util.o
Only in ./src: well.o
Only in .: test
Only in .: test.py
